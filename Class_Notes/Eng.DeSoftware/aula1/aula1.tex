\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[a4paper, total={6.5in, 10in}]{geometry}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{tgschola}
\usepackage{mathptmx}
\usepackage{fancyhdr}

\newcommand{\minus}{\scalebox{0.8}{$-$}}
\newcommand{\plus}{\scalebox{0.6}{$+$}}
\newcommand{\four}{\scalebox{0.8}{$4$}}

\title{Aula 1 Engenharia de Software}
\author{Benay Tomas}

\begin{document}

\fontfamily{qcs}\selectfont

\maketitle

\thispagestyle{empty}
\textbf{Princípios de Engenharia de software}

Formalidade, completeza, ocultação, localização, integridade e
abstração

\section{Fundamentos da engenharia de software}
O primeiro fundamento de engenharia de software são os
tipos de software.
\subsection*{Tipos de software}
\begin{itemize}
    \item Sistemas operacionais
    \item Aplicações/Programas
    \item Inteligência artificial
    \item Aplicações móveis
    \item Embarcados
    \item Web
\end{itemize}

\noindent
Como engenharia de software veio a existir?

\subsection*{Crise de software}
Nos anos 70, não havia padronização no desenvolvimento
de softwares. Com isso, muitos problemas surgiam, como por exemplo
estouro de cronograma, mal otimização, falta de documentação 
para manutenção de software, entre outros.

Nessa mesma época, alguns mitos surgiram e muitos
deles permanecem até hoje.

\subsection*{Modelo de processo}
Se trata de um fluxograma de processo para guiar
os desenvolvedores por todas as fases do projetos.

Esses processos são receitas constituidos de métodos
e ferramentas.

\noindent
\textbf{Processos fundamentais:}

Especificação de software $->$ implantação $->$
validação $->$ evolução

\noindent
Alguns desses modelos são:

\subsection*{Modelo de cascata}

\begin{center}
    \includegraphics*[height=5cm, width=12cm]{modeloCascata.png}
\end{center}

O modelo cascata também é chamado de modelo sequencial, o que significa
que ele segue uma sequência de passos e ao final entrega o produto e faz
as manutenções necessárias.

\subsection*{Modelo espiral}

\begin{center}
    \includegraphics*[height=7cm, width=9cm]{modeloEspiral.png}
\end{center}

A: Comunicação;
B: Planejamento;
C: Modelagem;
D: Construção e teste;
E: Entrega

Esse modelo é cíclico, que diferente do sequencial
após a entrega do produto, a manutenção executada nada mais é 
do que repetir as etapas anteriores mudando o que for necessário.

\subsection*{Modelo V}

\begin{center}
    \includegraphics*[height=6cm, width=10cm]{modeloV.png}
\end{center}

Nesse modelo a cada etapa, são feitos
testes.

\subsection*{Modelo incremental}

\begin{center}
    \includegraphics*[height=5cm, width=10cm]{modeloIncremental.png}
\end{center}

Nesse modelo, a cada uma certa quantidade de etapas
são feitos incrementos contínuos a partir daquela etapa.

Basicamente funciona como o modelo espiral com a diferença
é que são feitos incrementos enquanto fazendo as etapas e não ao final do modelo.

\section{Metodologias agéis}
Surgimento em 2000. Menos centrada
em documentação. Adaptativas. Orientada a pessoas e não processos.
Incremental e interativa.

\subsection*{Extreme Programming (XP)}

\begin{itemize}
    \item Rápido desenvolvimento.
    \item Requisitos se alteram muito.
    \item Simplicidade, comunicação e feedback.
\end{itemize}

\begin{center}
    \includegraphics*[height=6cm, width=10cm    ]{xp.png}
\end{center}

A: Planejamento;
B: Projeto;
C: Codificação;
D: Testes

Nessa metodologia a codificação é feita em pares,
dois desenvolvedores trabalham no mesmo processo.
Além disso, o processo de codificação pode ser repetido
múltiplas vezes.

Ao final é feito um incremento de software.

\noindent
\textbf{A equipe de trabalho consiste de:}

Gerente, coach, analista de testes, redator técnico e 
desenvolvedor.

\subsection*{SCRUM}
Essa é a mais usada hoje em dia.
Ela é composta de reuniões regulares (Stand Up Meeting).
É feito em ciclos (Sprints).

\noindent
\textbf{Equipe:}
\begin{itemize}
    \item Scrum Master
    \item Product Owner
    \item Scrum Team
\end{itemize}

\subsection*{Elementos importantes do SCRUM}
\begin{itemize}
    \item Product backlog
    \item Sprint backlog
    \item Sprints
    \item Kanban
    \item Pôquer de planejamento
\end{itemize}

Product backlogs são os requisitos gerais do projeto.
Sprint backlogs são os requisitos apenas das sprints.
Sprints são os ciclos do desenvolvimento do projeto.
Kanban é um quadro de trabalho para relembrar visualmente os sprints necessários,
esse quadro pode ser físico ou virtual (Trello).
Pôquer de planejamento é utilizado para apostar
em quanto tempo levará para terminar uma sprint.

\begin{center}
    \includegraphics*[height=8cm, width=15cm]{kanban.png}
\end{center}

\subsection*{Post-it para Kanban}
Os post-its do kanban são feitos pelas equipe mas existe um padrão
para eles também.

\begin{center}
    \includegraphics*[height=7cm, width=16cm]{postitkanban.png}
\end{center}

\subsection*{Esforço \hfill Dificuldade}
\begin{enumerate}
    \item Horas \hfill MB - Muito baixa
    \item 12 horas \hfill B - Baixa
    \item Dias \hfill A - Alta
    \item Semanas \hfill MA - Muito alta
    \item[] \hfill S - Sem dificuldade
\end{enumerate}

\newpage
\thispagestyle{headings}

\section{Gestão de configuração}
Identificar, organizar e controlar modificações no software.

Definir o que será gerenciado. Estabelecer responsável.
Estabelecer políticas de gerenciamento. Especificar ferramentas.
Descrever a estrutura do banco de dados.

\subsection*{Etapas}
Identificar $->$ controle de alteração $->$
controle de versão $->$ autoria de configuração $->$ relatos.

\subsection*{Gerenciamento}
\begin{itemize}
    \item Repositórios de códigos
    \item Baselines (releases)
    \item Branches (ramificações do código base)
\end{itemize}

\subsection*{Componentes para controle de versão.}

\begin{itemize}
    \item Código
    \item Documentação
    \item Diagramas
\end{itemize}

Esses componentes servem para manter a rastreabilidade dos itens.
Saber onde estão todos os elementos do software. Manter
a padronização dos itens.

\subsection*{Gerenciamentos de versões e releases}
\begin{itemize}
    \item[$>$] Releases $->$ São as versões finais alteradas (com novas funcionalidades)
    entregadas ao cliente.
    \item[$>$] Versões $->$ Alterações feitas no projeto principal que não
    são lançadas.
\end{itemize}

\section{Referências}
\begin{enumerate}
    \item Anotações das aulas
\end{enumerate}

\vfill
\begin{center}
    Curitiba

    2024
\end{center}

\end{document}
